# TCC (Tiny C Compiler) Integration with Akuma OS

This document details the process and solutions implemented to integrate the Tiny C Compiler (TCC) as a self-hosted compiler within the Akuma OS userspace. The primary goal is to enable `tcc` to compile simple C "Hello World" programs directly on the Akuma target.

## Overall Goal

To create a new userspace program, the `cc` binary (powered by `tinycc`), for Akuma OS. This compiler must be capable of compiling a basic "Hello World" C program on the target system, leveraging a Rust FFI wrapper and `libakuma` for OS communication. The `tcc` binary should be self-contained regarding its C runtime and header dependencies.

## Key Challenges and Solutions

### 1. Linking Issues with `cc` Crate and `rust-lld`

**Problem:** Initial attempts to compile `tinycc` (a large C codebase) directly using the `cc` crate's standard `compile("library_name")` method resulted in persistent `undefined symbol` linking errors. Investigation revealed that `rust-lld` (Rust's linker) was failing to properly link against static libraries (`.a` archives) generated by the `cc` crate, particularly an apparent `ranlib` issue where the archive's table of contents was empty or improperly indexed.

**Solution:** The build process in `userspace/tcc/build.rs` was modified to manually manage the compilation and archiving of C/Assembly source files.
*   Individual source files (`tinycc/tcc.c`, `src/libc_stubs.c`, `src/setjmp.S`) are compiled into separate object files (`.o`) using `cc::Build::compile()`. Note that `cc::Build::compile()` can produce `.o` files if only one file is added to the builder and the name passed to `compile` has a `.o` suffix.
*   These `.o` files are then manually combined into a *single* static library (`libtcc_all_objs.a`) using the system's `ar` utility. This monolithic archive ensures that all C-side symbols are present and properly indexed for `rust-lld`.
*   `rustc` is then instructed to link against this manually created `libtcc_all_objs.a`.

### 2. `time_t` Redefinition Compile Errors

**Problem:** Persistent `typedef` redefinition errors for `time_t` arose due to inconsistencies between how `time_t` was defined in custom headers and TCC's internal definitions, combined with potential caching issues during build.

**Solution:**
*   `time_t` was globally defined as `long long` via a `-Dtime_t="long long"` flag in `userspace/tcc/build.rs`, ensuring a consistent type across the entire C compilation.
*   Explicit `typedef time_t` declarations were removed from custom headers like `userspace/tcc/include/stddef.h` and `userspace/tcc/include/sys/types.h` to prevent redefinition conflicts.
*   The function signature for `time()` in `userspace/tcc/include/time.h` was explicitly defined as `time_t time(time_t *tloc);` to avoid `implicit int` warnings now that `time_t` is globally defined.

### 3. `setjmp`/`longjmp` Implementation

**Problem:** `tinycc` uses `setjmp` and `longjmp` for internal error handling, which require architecture-specific assembly implementations for AArch64.

**Solution:** An AArch64 assembly file, `userspace/tcc/src/setjmp.S`, was created to provide the necessary implementations for `setjmp` and `longjmp`, preserving and restoring register context as required by the calling convention.

### 4. `CONFIG_TCC_ELFINTERP` for Akuma OS

**Problem:** The default `CONFIG_TCC_ELFINTERP` in `tinycc` points to `/lib/ld-linux-aarch64.so.1`, which is the Linux dynamic linker. Akuma OS userspace applications are statically linked and do not use a dynamic linker. Embedding this path would be semantically incorrect for Akuma executables.

**Solution:** `CONFIG_TCC_ELFINTERP` in `userspace/tcc/src/config.h` was set to an empty string (`""`). This prevents TCC from embedding a non-existent dynamic linker path into the generated ELF binaries, aligning with Akuma OS's static linking model.

### 5. Self-Contained TCC Runtime Installation (`tcc install` command)

**Problem:** To make `tcc` truly self-hosted on Akuma, it needed a way to provide its own C runtime (`crt0.S`, `libc.c`) and standard headers without relying on external distribution mechanisms or manually copying files to the target filesystem.

**Solution:**
*   **Embedded Files**: All necessary C headers (from `userspace/tcc/include/`) and library source files (`userspace/tcc/lib/crt0.S`, `userspace/tcc/lib/libc.c`) are embedded directly into the `tcc` Rust binary using `include_str!` macros (defined in `FILES_TO_INSTALL` in `userspace/tcc/src/main.rs`).
*   **`tcc install` Command**: A new command-line argument handling (`tcc install`) was added to `userspace/tcc/src/main.rs`. When invoked, this command executes `install_tcc_runtime()`.
*   **Extraction Logic (`install_tcc_runtime`)**: This function iterates through the embedded `FILES_TO_INSTALL`. For each file, it:
    1.  Constructs the full target path under `/usr/` (e.g., `/usr/include/stdio.h`, `/usr/lib/crt0.S`).
    2.  Uses `libakuma::mkdir_p` to ensure parent directories exist.
    3.  Uses `libakuma::open` and `libakuma::write` to write the embedded content to the target path.
    4.  Utilizes a custom `PathBuf` implementation in `no_std` context for path manipulation.
*   **`config.h` Paths**: TCC's internal configuration (specifically `CONFIG_TCCDIR`, `CONFIG_TCC_SYSINCLUDE_PATHS`, `CONFIG_TCC_LIBPATHS`, `CONFIG_TCC_CRTPREFIX` in `userspace/tcc/src/config.h`) was updated to point directly to `/usr/include` and `/usr/lib`. This ensures that after `tcc install` is run, `tcc` automatically finds its runtime dependencies in the standard FHS locations.
*   **Build System Cleanup**: The `cp` commands that previously copied these files into the `bootstrap` directory (for disk image creation) were removed from `userspace/build.sh`, as `tcc` now handles its own runtime installation.

### Exact File Extraction Locations

When `tcc install` is executed, the embedded files will be written to the Akuma filesystem at the following locations:

**Base Installation Directory**: `/usr`

This setup makes TCC a self-sufficient C compiler that can bootstrap its own development environment on Akuma OS.