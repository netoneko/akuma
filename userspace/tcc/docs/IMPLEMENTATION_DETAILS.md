# TCC (Tiny C Compiler) Integration with Akuma OS

This document details the process and solutions implemented to integrate the Tiny C Compiler (TCC) as a self-hosted compiler within the Akuma OS userspace. The primary goal is to enable `tcc` to compile simple C "Hello World" programs directly on the Akuma target.

## Overall Goal

To create a new userspace program, the `cc` binary (powered by `tinycc`), for Akuma OS. This compiler must be capable of compiling a basic "Hello World" C program on the target system, leveraging a Rust FFI wrapper and `libakuma` for OS communication.

## Key Challenges and Solutions

### 1. Linking Issues with `cc` Crate and `rust-lld`

**Problem:** Initial attempts to compile `tinycc` (a large C codebase) directly using the `cc` crate's standard `compile("library_name")` method resulted in persistent `undefined symbol` linking errors. Investigation revealed that `rust-lld` (Rust's linker) was failing to properly link against static libraries (`.a` archives) generated by the `cc` crate, particularly an apparent `ranlib` issue where the archive's table of contents was empty or improperly indexed.

**Solution:** The build process in `userspace/tcc/build.rs` was modified to manually manage the compilation and archiving of C/Assembly source files.
*   Individual source files (`tinycc/tcc.c`, `src/libc_stubs.c`, `src/setjmp.S`) are compiled into separate object files (`.o`) using `cc::Build::compile()`. Note that `cc::Build::compile()` can produce `.o` files if only one file is added to the builder and the name passed to `compile` has a `.o` suffix.
*   These `.o` files are then manually combined into a *single* static library (`libtcc_all_objs.a`) using the system's `ar` utility. This monolithic archive ensures that all C-side symbols are present and properly indexed for `rust-lld`.
*   `rustc` is then instructed to link against this manually created `libtcc_all_objs.a`.

### 2. `time_t` Redefinition Compile Errors

**Problem:** Persistent `typedef` redefinition errors for `time_t` arose due to inconsistencies between how `time_t` was defined in custom headers and TCC's internal definitions, combined with potential caching issues during build.

**Solution:**
*   `time_t` was globally defined as `long long` via a `-Dtime_t="long long"` flag in `userspace/tcc/build.rs`, ensuring a consistent type across the entire C compilation.
*   Explicit `typedef time_t` declarations were removed from custom headers like `userspace/tcc/include/stddef.h` and `userspace/tcc/include/sys/types.h` to prevent redefinition conflicts.
*   The function signature for `time()` in `userspace/tcc/include/time.h` was explicitly defined as `time_t time(time_t *tloc);` to avoid `implicit int` warnings now that `time_t` is globally defined.

### 3. `setjmp`/`longjmp` Implementation

**Problem:** `tinycc` uses `setjmp` and `longjmp` for internal error handling, which require architecture-specific assembly implementations for AArch64.

**Solution:** An AArch64 assembly file, `userspace/tcc/src/setjmp.S`, was created to provide the necessary implementations for `setjmp` and `longjmp`, preserving and restoring register context as required by the calling convention.

### 4. `CONFIG_TCC_ELFINTERP` for Akuma OS

**Problem:** The default `CONFIG_TCC_ELFINTERP` in `tinycc` points to `/lib/ld-linux-aarch64.so.1`, which is the Linux dynamic linker. Akuma OS userspace applications are statically linked and do not use a dynamic linker. Embedding this path would be semantically incorrect for Akuma executables.

**Solution:** `CONFIG_TCC_ELFINTERP` in `userspace/tcc/src/config.h` was set to an empty string (`""`). This prevents TCC from embedding a non-existent dynamic linker path into the generated ELF binaries, aligning with Akuma OS's static linking model.

### 5. Stability and Runtime Fixes (2026)

Several critical issues were resolved to move TCC from a crashing state to a functional compiler producing working binaries.

**A. `vsnprintf` Synchronization and `*` Support**
*   **Problem**: TCC's verbose output uses `%*s` for indentation. The previous minimal `vsnprintf` did not handle the `*` width specifier, causing it to skip the `int` argument in the `va_list`. This desynchronized the argument pointer, leading to subsequent strings being interpreted as pointers to invalid memory, causing segmentation faults.
*   **Solution**: Replaced the minimal `vsnprintf` in `libc_stubs.c` with a robust implementation that correctly handles variable width (`*`), precision, and various length modifiers (`l`, `ll`, `z`).

**B. Memory Allocation Alignment (`Layout`)**
*   **Problem**: The Rust `malloc` wrapper used `Layout::from_size_align(size + 8, 8)`. If `size + 8` was not a multiple of 8, `Layout` creation could fail on some Rust versions, returning `NULL` to TCC. Additionally, `malloc(0)` was returning `NULL`, which some C programs treat as an error.
*   **Solution**: Updated `malloc`, `realloc`, and `free` in `main.rs` to always round the allocation size up to the nearest 8-byte boundary. Added support for `malloc(0)` returning a valid unique pointer.

**C. Cross-Compilation of Runtime Objects**
*   **Problem**: When building on macOS, `cc-rs` defaulted to the host compiler, producing Mach-O objects for `libc.o`, `crt1.o`, etc. TCC's ELF linker could not resolve symbols from these mismatched formats, leading to `undefined symbol 'printf'` errors.
*   **Solution**: Updated `build.rs` to explicitly pass `-target aarch64-none-elf` to the compiler for all runtime objects and support libraries.

**D. GNU Archive Format and Symbol Indexing**
*   **Problem**: On macOS, `ar` produces BSD-style archives with a `__.SYMDEF` member for the symbol table. TCC's ELF linker expects the GNU-style symbol table (named `/`). Furthermore, archives without a proper index caused symbol resolution failures.
*   **Solution**: 
    *   Modified `build.rs` to prefer `llvm-ar` and `llvm-ranlib` (from Homebrew paths if necessary).
    *   Forced the GNU archive format using the `--format=gnu` flag for `llvm-ar`.
    *   Explicitly ran `ranlib` on all generated archives to ensure a valid symbol map.

**E. Kernel-Side Relocation Support**
*   **Problem**: TCC generates position-independent-like code using a Global Offset Table (GOT) for strings and global data. It emits `R_AARCH64_RELATIVE` relocations that must be applied at load time. Akuma's `elf_loader` previously ignored these, leaving GOT entries as zero and causing null pointer dereferences (Data Aborts).
*   **Solution**: Updated `src/elf_loader.rs` in the Akuma kernel to parse the ELF section headers, locate `SHT_RELA` sections, and apply `R_AARCH64_RELATIVE` relocations by writing the `addend` into the target virtual address.

**F. Runtime `printf` Escaping and `__arm64_clear_cache`**
*   **Problem**: Compiled binaries printed `\n` literally instead of a newline because the minimal `libc.c` didn't handle the sequence. Also, TCC's internal runtime library (`lib-arm64.c`) failed to build due to a missing declaration of `__arm64_clear_cache`.
*   **Solution**:
    *   Improved `printf` in `lib/libc.c` to handle `\n` and added `%c` support.
    *   Added a declaration for `__arm64_clear_cache` in `include/stdint.h` and a stub in `lib/libc.c` to satisfy the compiler.

## MISSING PARTS

*   Update `built-in "pkg install"` so it would know to try to download the binary and if it does not
   exist try to download and extract an archive (Partially implemented: `paws` now handles this).
*   Implement more complete C library functions in `lib/libc.c` (e.g., `fopen`, `fread`) to allow more complex C programs to run.
*   Support more relocation types in the kernel ELF loader if needed for larger programs.
