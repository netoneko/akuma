//! Process Execution Tests
//!
//! Tests for user process execution during boot.

use crate::config;
use crate::console;
use crate::fs;
use crate::process;

/// Run all process tests
pub fn run_all_tests() {
    console::print("\n--- Process Execution Tests ---\n");

    // Re-enabled to investigate EC=0x0 crash
    test_echo2();

    // Minimal ELF loading verification (run before stdcheck)
    test_elftest();

    // Test stdcheck with mmap allocator
    test_stdcheck();

    // Test procfs stdin/stdout access
    test_procfs_stdio();

    console::print("--- Process Execution Tests Done ---\n\n");
}

/// Test minimal ELF loading with elftest binary
///
/// This is the simplest possible test - if the binary runs and exits with
/// code 42, ELF loading is working correctly.
fn test_elftest() {
    const ELFTEST_PATH: &str = "/bin/elftest";

    // Check if file exists first
    if fs::read_file(ELFTEST_PATH).is_err() {
        if config::FAIL_TESTS_IF_TEST_BINARY_MISSING {
            crate::safe_print!(64, 
                "[Test] {} not found - FAIL\n",
                ELFTEST_PATH
            );
            panic!("Required test binary not found");
        } else {
            crate::safe_print!(96, 
                "[Test] {} not found, skipping ELF loading test\n",
                ELFTEST_PATH
            );
            return;
        }
    }

    crate::safe_print!(96, "[Test] Executing {}...\n", ELFTEST_PATH);
    
    match process::exec_with_io(ELFTEST_PATH, None, None) {
        Ok((exit_code, _stdout)) => {
            // elftest exits with code 42 on success
            if exit_code == 42 {
                console::print("[Test] elftest PASSED (ELF loading verified)\n");
            } else {
                crate::safe_print!(96, 
                    "[Test] elftest FAILED: expected exit code 42, got {}\n",
                    exit_code
                );
            }
        }
        Err(e) => {
            crate::safe_print!(64, "[Test] Failed to execute elftest: {}\n", e);
        }
    }
}

/// Test the stdcheck binary if it exists (tests mmap allocator)
fn test_stdcheck() {
    const STDCHECK_PATH: &str = "/bin/stdcheck";

    // Check if file exists first
    if fs::read_file(STDCHECK_PATH).is_err() {
        if config::FAIL_TESTS_IF_TEST_BINARY_MISSING {
            crate::safe_print!(64, 
                "[Test] {} not found - FAIL\n",
                STDCHECK_PATH
            );
            panic!("Required test binary not found");
        } else {
            crate::safe_print!(96, 
                "[Test] {} not found, skipping mmap allocator test\n",
                STDCHECK_PATH
            );
            return;
        }
    }

    crate::safe_print!(128, "[Test] Executing {} with mmap allocator...\n", STDCHECK_PATH);

    match process::exec_with_io(STDCHECK_PATH, None, None) {
        Ok((exit_code, _stdout)) => {
            if exit_code == 0 {
                console::print("[Test] stdcheck PASSED\n");
            } else {
                crate::safe_print!(64, 
                    "[Test] stdcheck FAILED with exit code {}\n",
                    exit_code
                );
            }
        }
        Err(e) => {
            crate::safe_print!(64, "[Test] Failed to execute stdcheck: {}\n", e);
        }
    }
}

#[allow(dead_code)]
/// Test the echo2 binary if it exists
fn test_echo2() {
    const ECHO2_PATH: &str = "/bin/echo2";

    // Check if the binary exists
    match fs::read_file(ECHO2_PATH) {
        Ok(data) => {
            crate::safe_print!(96, 
                "[Test] Found {} ({} bytes), attempting to execute...\n",
                ECHO2_PATH,
                data.len()
            );

            // Try to create a process from the ELF
            match process::Process::from_elf("echo2", &data) {
                Ok(proc) => {
                    crate::safe_print!(96, 
                        "[Test] Process created: PID={}, entry={:#x}\n",
                        proc.pid, proc.context.pc
                    );
                    console::print("[Test] echo2 test PASSED (process creation succeeded)\n");

                    // Note: Actually executing the process would require
                    // the full scheduler integration. For now, we just verify
                    // that the ELF can be loaded.
                    drop(proc);
                }
                Err(e) => {
                    crate::safe_print!(64, "[Test] Failed to load echo2: {}\n", e);
                    console::print("[Test] echo2 test FAILED\n");
                }
            }
        }
        Err(_) => {
            if config::FAIL_TESTS_IF_TEST_BINARY_MISSING {
                crate::safe_print!(64, "[Test] {} not found - FAIL\n", ECHO2_PATH);
                panic!("Required test binary not found");
            } else {
                crate::safe_print!(64, "[Test] {} not found, skipping test\n", ECHO2_PATH);
            }
        }
    }
}

/// Check if a binary exists, respecting FAIL_TESTS_IF_TEST_BINARY_MISSING
fn check_binary_exists(path: &str) -> bool {
    if fs::read_file(path).is_err() {
        if config::FAIL_TESTS_IF_TEST_BINARY_MISSING {
            crate::safe_print!(64, "[Test] {} not found - FAIL\n", path);
            panic!("Required test binary not found");
        } else {
            crate::safe_print!(96, "[Test] {} not found, skipping procfs test\n", path);
            return false;
        }
    }
    true
}

/// Test procfs stdin/stdout access
///
/// This test verifies:
/// 1. /proc/<pid>/fd/0 (stdin) is readable via procfs
/// 2. /proc/<pid>/fd/1 (stdout) is readable via procfs
/// 3. Proper content is returned from process buffers
fn test_procfs_stdio() {
    const HELLO_PATH: &str = "/bin/hello";
    const ECHO2_PATH: &str = "/bin/echo2";

    // Check binaries exist (respect FAIL_TESTS_IF_TEST_BINARY_MISSING)
    if !check_binary_exists(HELLO_PATH) || !check_binary_exists(ECHO2_PATH) {
        return;
    }

    crate::safe_print!(64, "[Test] Testing procfs stdin/stdout access...\n");

    // 1. Spawn hello with "10 50" args (10 outputs, 50ms delay = ~500ms runtime)
    let hello_args = &["10", "50"];
    let (hello_thread_id, _hello_channel, hello_pid) = match process::spawn_process_with_channel(
        HELLO_PATH,
        Some(hello_args),
        None,
    ) {
        Ok(result) => result,
        Err(e) => {
            crate::safe_print!(96, "[Test] Failed to spawn hello: {}\n", e);
            return;
        }
    };

    // 2. Spawn echo2 with stdin data
    let stdin_data = b"test input for echo2\n";
    let (echo2_thread_id, _echo2_channel, echo2_pid) = match process::spawn_process_with_channel(
        ECHO2_PATH,
        None,
        Some(stdin_data),
    ) {
        Ok(result) => result,
        Err(e) => {
            crate::safe_print!(96, "[Test] Failed to spawn echo2: {}\n", e);
            return;
        }
    };

    crate::safe_print!(
        96,
        "[Test] Spawned hello (PID {}) and echo2 (PID {})\n",
        hello_pid,
        echo2_pid
    );

    // 3. Wait ~500ms for processes to run (hello takes ~450ms)
    // Use polling with yield since there's no sleep_ms in kernel
    let wait_start = crate::timer::uptime_us();
    let wait_duration_us = 500_000; // 500ms
    while crate::timer::uptime_us() - wait_start < wait_duration_us {
        crate::threading::yield_now();
    }

    // 4. Read echo2's stdin via procfs: /proc/<echo2_pid>/fd/0
    let stdin_path = alloc::format!("/proc/{}/fd/0", echo2_pid);
    match fs::read_file(&stdin_path) {
        Ok(data) => {
            if data == stdin_data {
                crate::safe_print!(64, "[Test] procfs stdin read: PASSED\n");
            } else {
                crate::safe_print!(
                    128,
                    "[Test] procfs stdin MISMATCH: expected {} bytes, got {}\n",
                    stdin_data.len(),
                    data.len()
                );
            }
        }
        Err(e) => {
            crate::safe_print!(96, "[Test] Failed to read {}: {:?}\n", stdin_path, e);
        }
    }

    // 5. Read hello's stdout via procfs: /proc/<hello_pid>/fd/1
    let stdout_path = alloc::format!("/proc/{}/fd/1", hello_pid);
    match fs::read_file(&stdout_path) {
        Ok(data) => {
            // Verify stdout contains expected content
            if let Ok(s) = core::str::from_utf8(&data) {
                if s.contains("hello (10/10)") && s.contains("hello: done") {
                    crate::safe_print!(64, "[Test] procfs stdout read: PASSED\n");
                } else {
                    crate::safe_print!(
                        128,
                        "[Test] procfs stdout missing expected content (got {} bytes)\n",
                        data.len()
                    );
                }
            } else {
                crate::safe_print!(64, "[Test] procfs stdout: invalid UTF-8\n");
            }
        }
        Err(e) => {
            crate::safe_print!(96, "[Test] Failed to read {}: {:?}\n", stdout_path, e);
        }
    }

    // Cleanup: wait for processes to exit
    // Note: we don't have waitpid in this context, but processes should have exited by now
    crate::threading::cleanup_terminated();

    crate::safe_print!(64, "[Test] procfs stdio test complete\n");
}
